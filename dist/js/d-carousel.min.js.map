{"version":3,"file":"d-carousel.min.js","sources":["../../node_modules/bezier-easing/src/index.js","../../src/js/supportsPassive.js","../../src/js/rafThrottle.js","../../src/js/main.js"],"sourcesContent":["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    }\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n","// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// Test via a getter in the options object to see if the passive property is accessed\nlet supportsPassive = false;\ntry {\n  const opts = Object.defineProperty({}, 'passive', {\n    get: function() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener('test', null, opts);\n} catch (e) {}\n\nexport default supportsPassive;","export default () => {\n\n  let raf = false;\n\n  const throttler = (callback) => {\n    if (!raf) {\n      raf = true;\n      requestAnimationFrame((timestamp) => {\n        callback(timestamp);\n        raf = false;\n      });\n    }\n  };\n\n  return throttler;\n\n};","import BezierEasing from 'bezier-easing';\nimport rafThrottle from './rafThrottle';\nimport supportsPassive from './supportsPassive';\n\nconst defaultOptions = {\n  paddingLeft: false, // if set to true then script will check outer element for a padding left value which offsets the carousel items. Much like googles one on desktop\n  outerSelector: '.d-carousel__outer',\n  innerSelector: '.d-carousel__inner',\n  itemsSelector: '.d-carousel__item',\n  nextSelector: '.d-carousel__next',\n  prevSelector: '.d-carousel__prev',\n  easing: [0.42,0,0.58,1], // ease-in-out, used for animating the scroll. See https://github.com/gre/bezier-easing for options\n  delta: () => { // will count an item as fully in view if within ${x}px of delta\n    return 8;\n  },\n  duration: () => { // possibly needs to be worked out for the amount that is being scrolled. E.g 100px will always scroll in 0.1s\n    return 500;\n  },\n};\n\nconst HALF_A_FRAME = 8; // Around half of a frame, based on 60fps as most common frame rate\n\n\nconst throttler = rafThrottle();\nconst windowResizeFns = [];\nconst windowResize = () => {\n  throttler(() => {\n    windowResizeFns.forEach((fn) => fn());\n  });\n}\n\nlet init = false;\n\n/** \n * Times dCarousel was used to initalise a carousel. Used inregards to \n * the window resize event listener. Which we only want one running at a time\n */\nlet timesInit = 0;\n\n\n\nexport default function dCarousel(el, optionsArg) {\n\n  const eventHandlerOptions = supportsPassive ? { passive: true } : false;\n\n  const options = Object.assign({}, defaultOptions, optionsArg);\n  const $outer = el.querySelector(options.outerSelector);\n  const $inner = el.querySelector(options.innerSelector);\n  const $items = Array.from(el.querySelectorAll(options.itemsSelector));\n  const $next = el.querySelector(options.nextSelector);\n  const $prev = el.querySelector(options.prevSelector);\n  const noItems = $items.length;\n  const easing = BezierEasing.apply(null, options.easing);\n\n  let containerWidth = el.offsetWidth;\n  let paddingLeft = options.paddingLeft ? parseFloat(window.getComputedStyle($outer).paddingLeft.replace('px', ''), 10) : 0;\n  let innerWidth = $inner.offsetWidth;\n  let itemWidth = $items[0].offsetWidth;\n  let maxScrollLeft = innerWidth - containerWidth + paddingLeft;\n  let scrollLeft;\n  let animating = false;\n\n  const getFirstItemShowing = () => { // based off an index of 1\n    const start = 0 - paddingLeft;\n    return Math.ceil((start + scrollLeft - options.delta()) / itemWidth) + 1;\n  };\n\n  const getLastItemShowing = () => { // based off an index of 1\n    const start = 0 - paddingLeft;\n    return Math.floor((start + scrollLeft + containerWidth + options.delta()) / itemWidth);\n  };\n\n  const getItemsShowing = () => { // returns the indexes of the items showing in an array. E.g only first item showing would return [0]\n    const first = getFirstItemShowing() - 1;\n    const last = getLastItemShowing() - 1;\n    const array = [];\n    for (let i = first; i <= last; i++) {\n      array.push(i);\n    }\n    return array;\n  };\n\n  \n  const outerScroll = () => {\n    scrollLeft = $outer.scrollLeft;\n\n    const customEvent = new CustomEvent('dCarousel:scroll', {\n      detail: {\n        scrollLeft,\n      }\n    });\n\n    // button stuff\n    if (scrollLeft !== 0) {\n      $prev.classList.remove('disabled');\n    } else if (scrollLeft === 0) {\n      $prev.classList.add('disabled');\n    }\n    \n    // minus 1 as if scrollLeft is a decimal then it may not be possible to fully match the maxScrollLeft. \n    // So instead we will aim to be within 1px of the maxScrollLeft\n    if (scrollLeft < maxScrollLeft - 1) {\n      $next.classList.remove('disabled');\n    } else if (scrollLeft >= maxScrollLeft - 1) {\n      $next.classList.add('disabled');\n    }\n    el.dispatchEvent(customEvent);\n  };\n\n  const outerScrollDebounced = () => {\n    throttler(outerScroll);\n  };\n\n  const scrollOuter = (x) => {\n\n    animating = true;\n    const diff = scrollLeft - x;\n\n    const duration = options.duration({\n      itemWidth,\n      containerWidth,\n      diff: Math.abs(diff),\n    });\n    \n    const startingScrollLeft = scrollLeft;\n    let start = false;\n    const tick = (timestamp) => {\n      const lastTick = start === false ? false : ((timestamp - start) + HALF_A_FRAME) >= duration;\n      if (start === false) {\n        start = timestamp;\n      } else {\n        if (lastTick) {\n          $outer.scrollLeft = x;\n          animating = false;\n        } else {\n          const msDiff = timestamp - start; // ms difference between current frame and last one\n          const percentage = easing(msDiff / duration); // the percentage of x that should to be scrolled to\n          const xValue = diff * percentage; // x value that scrollLeft should be\n\n          if (diff < 0) { // going to the right\n            $outer.scrollLeft = startingScrollLeft + Math.abs(xValue);\n          } else { // going to the left\n            $outer.scrollLeft = startingScrollLeft - xValue;\n          }\n          \n        }\n        \n      }\n      \n      if (lastTick === false) requestAnimationFrame(tick);\n    };\n\n    requestAnimationFrame(tick); \n\n  };\n\n  const windowResizeFunction = () => {\n    containerWidth = el.offsetWidth;\n    paddingLeft = options.paddingLeft ? parseFloat(window.getComputedStyle($outer).paddingLeft.replace('px', ''), 10) : 0;\n    innerWidth = $inner.offsetWidth;\n    itemWidth = $items[0].offsetWidth;\n    maxScrollLeft = innerWidth - containerWidth + paddingLeft;\n    outerScroll();\n  };\n\n  const nextClick = () => {\n    if (animating === true) return;\n    const start = 0 - paddingLeft;\n    const lastIndexFullyShowing = getLastItemShowing();\n    if (lastIndexFullyShowing === noItems) {\n      scrollOuter(maxScrollLeft);\n      return;\n    }\n    const nextItem = lastIndexFullyShowing + 1;\n    const x = Math.abs(start) + Math.min((nextItem * itemWidth) - itemWidth, innerWidth - containerWidth);\n    scrollOuter(x);\n  };\n\n  const prevClick = () => {\n    if (animating === true) return;\n    const start = 0 - paddingLeft;\n    const firstItemFullyShowing = getFirstItemShowing();\n    if (firstItemFullyShowing === 1) {\n      scrollOuter(0);\n      return;\n    }\n    const prevItem = firstItemFullyShowing - 1;\n    const x = Math.abs(start) + Math.max((prevItem * itemWidth) - containerWidth, start);\n    scrollOuter(x);\n  };\n\n  const destroy = () => {\n    timesInit--;\n\n    // Removed window resize event listener\n    if (timesInit === 0) {\n      window.removeEventListener('resize', windowResize, false);\n    }\n\n    $outer.removeEventListener('scroll', outerScrollDebounced, eventHandlerOptions);\n    $next.removeEventListener('click', nextClick);\n    $prev.removeEventListener('click', prevClick);\n\n    el.classList.remove('init');\n  };\n\n\n  windowResizeFns.push(windowResizeFunction);\n\n  timesInit++;\n\n  if (init === false) {\n    init = true;\n    // only add event listener if dCarousel is called at least once\n    window.addEventListener('resize', windowResize, false);\n  }\n\n  $outer.addEventListener('scroll', outerScrollDebounced, eventHandlerOptions);\n  $next.addEventListener('click', nextClick);\n  $prev.addEventListener('click', prevClick);\n\n  el.classList.add('init');\n\n  // run this function on init to work out the button states\n  outerScroll();\n\n\n  return {\n    destroy,\n    getItemsShowing,\n    forceRefresh: windowResizeFunction, // force the calculations to take place again\n  };\n\n}"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","A","aA1","aA2","B","C","calcBezier","aT","getSlope","mX1","mY1","mX2","mY2","Error","sampleValues","Array","i","getTForX","aX","intervalStart","currentSample","lastSample","guessForT","initialSlope","aGuessT","currentSlope","newtonRaphsonIterate","aA","aB","currentX","currentT","Math","abs","binarySubdivide","x","supportsPassive","opts","Object","defineProperty","addEventListener","e","raf","HALF_A_FRAME","throttler","callback","timestamp","windowResizeFns","windowResize","forEach","fn","init","timesInit","el","optionsArg","eventHandlerOptions","passive","options","assign","defaultOptions","$outer","querySelector","outerSelector","$inner","innerSelector","$items","from","querySelectorAll","itemsSelector","$next","nextSelector","$prev","prevSelector","noItems","length","easing","BezierEasing","apply","containerWidth","offsetWidth","paddingLeft","parseFloat","window","getComputedStyle","replace","innerWidth","itemWidth","maxScrollLeft","scrollLeft","animating","getFirstItemShowing","start","ceil","delta","getLastItemShowing","floor","outerScroll","customEvent","CustomEvent","classList","remove","add","dispatchEvent","outerScrollDebounced","scrollOuter","diff","duration","startingScrollLeft","tick","lastTick","percentage","xValue","requestAnimationFrame","windowResizeFunction","nextClick","lastIndexFullyShowing","nextItem","min","prevClick","firstItemFullyShowing","prevItem","max","push","removeEventListener","first","last","array"],"mappings":"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"}