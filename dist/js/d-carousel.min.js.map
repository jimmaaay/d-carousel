{"version":3,"file":"d-carousel.min.js","sources":["../../node_modules/bezier-easing/src/index.js","../../src/js/supportsPassive.js","../../src/js/main.js","../../src/js/rafThrottle.js"],"sourcesContent":["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    }\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n","// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// Test via a getter in the options object to see if the passive property is accessed\nlet supportsPassive = false;\ntry {\n  const opts = Object.defineProperty({}, 'passive', {\n    get: function() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener('test', null, opts);\n} catch (e) {}\n\nexport default supportsPassive;","import BezierEasing from 'bezier-easing';\nimport rafThrottle from './rafThrottle';\nimport supportsPassive from './supportsPassive';\n\nconst defaultOptions = {\n  paddingLeft: false, // if set to true then script will check outer element for a padding left value which offsets the carousel items. Much like googles one on desktop\n  outerSelector: '.d-carousel__outer',\n  innerSelector: '.d-carousel__inner',\n  itemsSelector: '.d-carousel__item',\n  nextSelector: '.d-carousel__next',\n  prevSelector: '.d-carousel__prev',\n  easing: [0.42,0,0.58,1], // ease-in-out, used for animating the scroll. See https://github.com/gre/bezier-easing for options\n  delta: () => { // will count an item as fully in view if within ${x}px of delta\n    return 8;\n  },\n  duration: () => { // possibly needs to be worked out for the amount that is being scrolled. E.g 100px will always scroll in 0.1s\n    return 500;\n  },\n};\n\nconst HALF_A_FRAME = 8; // Around half of a frame, based on 60fps as most common frame rate\n\n\nconst throttler = rafThrottle();\nconst windowResizeFns = [];\nconst windowResize = () => {\n  throttler(() => {\n    windowResizeFns.forEach((fn) => fn());\n  });\n}\n\nlet init = false;\n\n\n\nexport default function dCarousel(el, optionsArg) {\n\n  const options = Object.assign({}, defaultOptions, optionsArg);\n  const $outer = el.querySelector(options.outerSelector);\n  const $inner = el.querySelector(options.innerSelector);\n  const $items = Array.from(el.querySelectorAll(options.itemsSelector));\n  const $next = el.querySelector(options.nextSelector);\n  const $prev = el.querySelector(options.prevSelector);\n  const noItems = $items.length;\n  const easing = BezierEasing.apply(null, options.easing);\n\n  let containerWidth = el.offsetWidth;\n  let paddingLeft = options.paddingLeft ? parseFloat(window.getComputedStyle($outer).paddingLeft.replace('px', ''), 10) : 0;\n  let innerWidth = $inner.offsetWidth;\n  let itemWidth = $items[0].offsetWidth;\n  let maxScrollLeft = innerWidth - containerWidth + paddingLeft;\n  let scrollLeft;\n  let animating = false;\n\n  const getFirstItemShowing = () => { // based off an index of 1\n    const start = 0 - paddingLeft;\n    return Math.ceil((start + scrollLeft - options.delta()) / itemWidth) + 1;\n  };\n\n  const getLastItemShowing = () => { // based off an index of 1\n    const start = 0 - paddingLeft;\n    return Math.floor((start + scrollLeft + containerWidth + options.delta()) / itemWidth);\n  };\n\n  const getItemsShowing = () => { // returns the indexes of the items showing in an array. E.g only first item showing would return [0]\n    const first = getFirstItemShowing() - 1;\n    const last = getLastItemShowing() - 1;\n    const array = [];\n    for (let i = first; i <= last; i++) {\n      array.push(i);\n    }\n    return array;\n  };\n\n  \n  const outerScroll = () => {\n    scrollLeft = $outer.scrollLeft;\n\n    const customEvent = new CustomEvent('dCarousel:scroll', {\n      detail: {\n        scrollLeft,\n      }\n    });\n\n    // button stuff\n    if (scrollLeft !== 0) {\n      $prev.classList.remove('disabled');\n    } else if (scrollLeft === 0) {\n      $prev.classList.add('disabled');\n    }\n    \n    // minus 1 as if scrollLeft is a decimal then it may not be possible to fully match the maxScrollLeft. \n    // So instead we will aim to be within 1px of the maxScrollLeft\n    if (scrollLeft < maxScrollLeft - 1) {\n      $next.classList.remove('disabled');\n    } else if (scrollLeft >= maxScrollLeft - 1) {\n      $next.classList.add('disabled');\n    }\n    el.dispatchEvent(customEvent);\n  };\n\n  const outerScrollDebounced = () => {\n    throttler(outerScroll);\n  };\n\n  const scrollOuter = (x) => {\n\n    animating = true;\n    const diff = scrollLeft - x;\n\n    const duration = options.duration({\n      itemWidth,\n      containerWidth,\n      diff: Math.abs(diff),\n    });\n    \n    const startingScrollLeft = scrollLeft;\n    let start = false;\n    const tick = (timestamp) => {\n      const lastTick = start === false ? false : ((timestamp - start) + HALF_A_FRAME) >= duration;\n      if (start === false) {\n        start = timestamp;\n      } else {\n        if (lastTick) {\n          $outer.scrollLeft = x;\n          animating = false;\n        } else {\n          const msDiff = timestamp - start; // ms difference between current frame and last one\n          const percentage = easing(msDiff / duration); // the percentage of x that should to be scrolled to\n          const xValue = diff * percentage; // x value that scrollLeft should be\n\n          if (diff < 0) { // going to the right\n            $outer.scrollLeft = startingScrollLeft + Math.abs(xValue);\n          } else { // going to the left\n            $outer.scrollLeft = startingScrollLeft - xValue;\n          }\n          \n        }\n        \n      }\n      \n      if (lastTick === false) requestAnimationFrame(tick);\n    };\n\n    requestAnimationFrame(tick); \n\n  };\n\n  const windowResizeFunction = () => {\n    containerWidth = el.offsetWidth;\n    paddingLeft = options.paddingLeft ? parseFloat(window.getComputedStyle($outer).paddingLeft.replace('px', ''), 10) : 0;\n    innerWidth = $inner.offsetWidth;\n    itemWidth = $items[0].offsetWidth;\n    maxScrollLeft = innerWidth - containerWidth + paddingLeft;\n    outerScroll();\n  };\n\n\n  windowResizeFns.push(windowResizeFunction);\n\n  if (init === false) {\n    init = true;\n    // only add event listener if dCarousel is called at least once\n    window.addEventListener('resize', windowResize, false);\n  }\n\n  $outer.addEventListener('scroll', outerScrollDebounced, supportsPassive ? { passive: true } : false);\n\n  $next.addEventListener('click', () => {\n    if (animating === true) return;\n    const start = 0 - paddingLeft;\n    const lastIndexFullyShowing = getLastItemShowing();\n    if (lastIndexFullyShowing === noItems) {\n      scrollOuter(maxScrollLeft);\n      return;\n    }\n    const nextItem = lastIndexFullyShowing + 1;\n    const x = Math.abs(start) + Math.min((nextItem * itemWidth) - itemWidth, innerWidth - containerWidth);\n    scrollOuter(x);\n  });\n\n  $prev.addEventListener('click', () => {\n    if (animating === true) return;\n    const start = 0 - paddingLeft;\n    const firstItemFullyShowing = getFirstItemShowing();\n    if (firstItemFullyShowing === 1) {\n      scrollOuter(0);\n      return;\n    }\n    const prevItem = firstItemFullyShowing - 1;\n    const x = Math.abs(start) + Math.max((prevItem * itemWidth) - containerWidth, start);\n    scrollOuter(x);\n  });\n\n  el.classList.add('init');\n\n  // run this function on init to work out the button states\n  outerScroll();\n\n\n  return {\n    getItemsShowing,\n    forceRefresh: windowResizeFunction, // force the calculations to take place again\n  };\n\n}","export default () => {\n\n  let raf = false;\n\n  const throttler = (callback) => {\n    if (!raf) {\n      raf = true;\n      requestAnimationFrame((timestamp) => {\n        callback(timestamp);\n        raf = false;\n      });\n    }\n  };\n\n  return throttler;\n\n};"],"names":["A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","newtonRaphsonIterate","aGuessT","NEWTON_ITERATIONS","currentSlope","NEWTON_MIN_SLOPE","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","mY1","mY2","getTForX","intervalStart","currentSample","lastSample","sampleValues","guessForT","initialSlope","Error","Array","x","supportsPassive","opts","Object","defineProperty","addEventListener","e","HALF_A_FRAME","throttler","raf","callback","timestamp","windowResizeFns","windowResize","forEach","fn","init","el","optionsArg","options","assign","defaultOptions","$outer","querySelector","outerSelector","$inner","innerSelector","$items","from","querySelectorAll","itemsSelector","$next","nextSelector","$prev","prevSelector","noItems","length","easing","BezierEasing","apply","containerWidth","offsetWidth","paddingLeft","parseFloat","window","getComputedStyle","replace","innerWidth","itemWidth","maxScrollLeft","scrollLeft","animating","getFirstItemShowing","start","ceil","delta","getLastItemShowing","floor","outerScroll","customEvent","CustomEvent","classList","remove","add","dispatchEvent","scrollOuter","diff","duration","startingScrollLeft","tick","lastTick","percentage","xValue","requestAnimationFrame","windowResizeFunction","push","passive","lastIndexFullyShowing","nextItem","min","firstItemFullyShowing","prevItem","max","first","last","array"],"mappings":"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"}