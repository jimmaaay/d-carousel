{"version":3,"file":"main.min.js","sources":["../../node_modules/bezier-easing/src/index.js","../../src/js/supportsPassive.js","../../src/js/main.js","../../src/js/rafThrottle.js"],"sourcesContent":["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    }\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n","// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n// Test via a getter in the options object to see if the passive property is accessed\nlet supportsPassive = false;\ntry {\n  const opts = Object.defineProperty({}, 'passive', {\n    get: function() {\n      supportsPassive = true;\n    }\n  });\n  window.addEventListener('test', null, opts);\n} catch (e) {}\n\nexport default supportsPassive;","import BezierEasing from 'bezier-easing';\nimport rafThrottle from './rafThrottle';\nimport supportsPassive from './supportsPassive';\n\nconst defaultOptions = {\n  container: window, // container is used to determine the width of the carousel. As most likely use case is full with use window\n  paddingLeft: false, // if set to true then script will check outer element for a padding left value which offsets the carousel items. Much like googles one on desktop\n  outerSelector: '.j-carousel__outer',\n  innerSelector: '.j-carousel__inner',\n  itemsSelector: '.j-carousel__item',\n  nextSelector: '.j-carousel__next',\n  prevSelector: '.j-carousel__prev',\n  easing: [0.42,0,0.58,1], // ease-in-out, used for animating the scroll. See https://github.com/gre/bezier-easing for options\n  delta: () => { // will count an item as fully in view if within ${x}px of delta\n    return 8;\n  },\n  duration: () => { // possibly needs to be worked out for the amount that is being scrolled. E.g 100px will always scroll in 0.1s\n    return 500;\n  },\n};\n\nconst HALF_A_FRAME = 8; // Around half of a frame, based on 60fps as most common frame rate\n\n\nconst throttler = rafThrottle();\nconst windowResizeFns = [];\nconst windowResize = () => {\n  throttler(() => {\n    windowResizeFns.forEach((fn) => fn());\n  });\n}\n\nlet init = false;\n\n\n\nexport default function jCarousel(el, optionsArg) {\n\n  const options = Object.assign({}, defaultOptions, optionsArg);\n  const $outer = el.querySelector(options.outerSelector);\n  const $inner = el.querySelector(options.innerSelector);\n  const $items = Array.from(el.querySelectorAll(options.itemsSelector));\n  const $next = el.querySelector(options.nextSelector);\n  const $prev = el.querySelector(options.prevSelector);\n  const noItems = $items.length;\n  const easing = BezierEasing.apply(null, options.easing);\n\n  let containerWidth = options.container === window ? options.container.innerWidth : options.container.offsetWidth;\n  let paddingLeft = options.paddingLeft ? parseFloat(window.getComputedStyle($outer).paddingLeft.replace('px', ''), 10) : 0;\n  let innerWidth = $inner.offsetWidth;\n  let itemWidth = $items[0].offsetWidth;\n  let maxScrollLeft = innerWidth - containerWidth + paddingLeft;\n  let scrollLeft;\n  let animating = false;\n  \n  const outerScroll = () => {\n    scrollLeft = $outer.scrollLeft;\n\n    // button stuff\n    if (scrollLeft !== 0) {\n      $prev.classList.remove('disabled');\n    } else if (scrollLeft === 0) {\n      $prev.classList.add('disabled');\n    }\n    \n    // minus 1 as if scrollLeft is a decimal then it may not be possible to fully match the maxScrollLeft. \n    // So instead we will aim to be within 1px of the maxScrollLeft\n    if (scrollLeft < maxScrollLeft - 1) {\n      $next.classList.remove('disabled');\n    } else if (scrollLeft >= maxScrollLeft - 1) {\n      $next.classList.add('disabled');\n    }\n    \n  };\n\n  const outerScrollDebounced = () => {\n    throttler(outerScroll);\n  };\n\n  const scrollOuter = (x) => {\n\n    animating = true;\n    const diff = scrollLeft - x;\n\n    const duration = options.duration({\n      itemWidth,\n      containerWidth,\n      diff: Math.abs(diff),\n    });\n    \n    const startingScrollLeft = scrollLeft;\n    let start = false;\n    const tick = (timestamp) => {\n      const lastTick = start === false ? false : ((timestamp - start) + HALF_A_FRAME) >= duration;\n      if (start === false) {\n        start = timestamp;\n      } else {\n        if (lastTick) {\n          $outer.scrollLeft = x;\n          animating = false;\n        } else {\n          const msDiff = timestamp - start; // ms difference between current frame and last one\n          const percentage = easing(msDiff / duration); // the percentage of x that should to be scrolled to\n          const xValue = diff * percentage; // x value that scrollLeft should be\n\n          if (diff < 0) { // going to the right\n            $outer.scrollLeft = startingScrollLeft + Math.abs(xValue);\n          } else { // going to the left\n            $outer.scrollLeft = startingScrollLeft - xValue;\n          }\n          \n        }\n        \n      }\n      \n      if (lastTick === false) requestAnimationFrame(tick);\n    };\n\n    requestAnimationFrame(tick); \n\n  };\n\n  windowResizeFns.push(() => {\n    containerWidth = options.container === window ? options.container.innerWidth : options.container.offsetWidth;\n    paddingLeft = options.paddingLeft ? parseFloat(window.getComputedStyle($outer).paddingLeft.replace('px', ''), 10) : 0;\n    innerWidth = $inner.offsetWidth;\n    itemWidth = $items[0].offsetWidth;\n    maxScrollLeft = innerWidth - containerWidth + paddingLeft;  \n    outerScroll();\n  });\n\n  if (init === false) {\n    init = true;\n    // only add event listener if jCarousel is called at least once\n    window.addEventListener('resize', windowResize, false);\n  }\n\n  $outer.addEventListener('scroll', outerScrollDebounced, supportsPassive ? { passive: true } : false);\n\n  $next.addEventListener('click', () => {\n    if (animating === true) return;\n    const start = 0 - paddingLeft;\n    const lastIndexFullyShowing = Math.floor((start + scrollLeft + containerWidth + options.delta()) / itemWidth);\n    if (lastIndexFullyShowing === noItems) {\n      scrollOuter(maxScrollLeft);\n      return;\n    }\n    const nextItem = lastIndexFullyShowing + 1;\n    const x = Math.abs(start) + Math.min((nextItem * itemWidth) - itemWidth, innerWidth - containerWidth);\n    scrollOuter(x);\n  });\n\n  $prev.addEventListener('click', () => {\n    if (animating === true) return;\n    const start = 0 - paddingLeft;\n    const firstItemFullyShowing = Math.ceil((start + scrollLeft - options.delta()) / itemWidth) + 1;\n    if (firstItemFullyShowing === 1) {\n      scrollOuter(0);\n      return;\n    }\n    const prevItem = firstItemFullyShowing - 1;\n    const x = Math.abs(start) + Math.max((prevItem * itemWidth) - containerWidth, start);\n    scrollOuter(x);\n  });\n\n  // run this function on init to work out the button states\n  outerScroll();\n\n}","export default () => {\n\n  let raf = false;\n\n  const throttler = (callback) => {\n    if (!raf) {\n      raf = true;\n      requestAnimationFrame((timestamp) => {\n        callback(timestamp);\n        raf = false;\n      });\n    }\n  };\n\n  return throttler;\n\n};"],"names":["A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","newtonRaphsonIterate","aGuessT","NEWTON_ITERATIONS","currentSlope","NEWTON_MIN_SLOPE","kSplineTableSize","kSampleStepSize","float32ArraySupported","Float32Array","mY1","mY2","getTForX","intervalStart","currentSample","lastSample","sampleValues","guessForT","initialSlope","Error","Array","x","supportsPassive","opts","Object","defineProperty","addEventListener","e","window","HALF_A_FRAME","throttler","raf","callback","timestamp","windowResizeFns","windowResize","forEach","fn","init","el","optionsArg","options","assign","defaultOptions","$outer","querySelector","outerSelector","$inner","innerSelector","$items","from","querySelectorAll","itemsSelector","$next","nextSelector","$prev","prevSelector","noItems","length","easing","BezierEasing","apply","containerWidth","container","innerWidth","offsetWidth","paddingLeft","parseFloat","getComputedStyle","replace","itemWidth","maxScrollLeft","scrollLeft","animating","outerScroll","classList","remove","add","scrollOuter","diff","duration","startingScrollLeft","start","tick","lastTick","percentage","xValue","requestAnimationFrame","push","passive","lastIndexFullyShowing","floor","delta","nextItem","min","firstItemFullyShowing","ceil","prevItem","max"],"mappings":"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"}